import java.lang.Math;

public class NewtonInterpolation
{
	public static double newton(double x0, int n, double[] x, double[] y)
	{
		double[][] dy = new double[n-1][n-1];  //Масив розділених різниць
		for(int i=1; i<n; i++)
			dy[0][i-1] = (y[i]-y[i-1])/(x[i]-x[i-1]);  //Обчислення першого рядка розділених різниць
		int k=2;  //Певне число, яке позначає різницю між індексами
		for(int i=1; i<n-1; i++)
		{
			for(int j=1; j<n-i; j++)
				dy[i][j-1] = (dy[i-1][j]-dy[i-1][j-1])/(x[k+j-1]-x[j-1]); //Загальна формула обчислення інших рядків розділених різниць
			k+=1;
		}
		double[] sum = new double[n-1];  //Масив сум модулів елементів рядків масиву розділених різниць
		int[] amount = new int[n-1];  //Масив кількості елементів в кожному рядку масиву розділених різниць
		int p=0;  //Число, яке позначає рядок, після якого подальші розділені різниці не мають сенсу
		for(int i=0; i<n-1; i++)
		{
			sum[i]=0;
			amount[i]=0;
			for(int j=0; j<n-1-i; j++)
			{
				sum[i]+=Math.abs(dy[i][j]);
				amount[i]+=1;
			}
		}
		for(int i=0; i<n-1; i++)
		{
			//Якщо середнє арифметичне всіх елементів, взятих по модулю, рядків менше за 0,001...
			if((sum[i]/amount[i]) < 0.001)
			{
			//...то цей рядок розділених різниць не має сенсу і не вплине на точність інтерполяції, тому попередній рядок - останній
				p=i-1;
				break;
			}
			else
				p=i; //інакше всі рядки розділених різниць важливі для інтерполяції
		}
		System.out.println("Таблиця розділених різниць");
		for(int i=0; i<n-1; i++)
		{
			for(int j=0; j<n-1-i; j++)
				System.out.printf("%.3f  ", dy[i][j]);  //Виведення таблиці розділених різниць на екран...
			System.out.println();
			if(i == p)  //...з урахуванням важливості
				break;
		}
		double[] omega = new double[p+1]; //Масив обчислення (x-x0), (x-x0)(x-x1) ... 
		double[] dy0 = new double[p+2]; //Масив розділених різниць, які фігурують в основній формулі інтерполяційного поліному Ньютона
		//Якщо точка, значення в котрій треба обчислити, знаходиться лівіше від середини відрізка, застосовуємо нтерполяцію вперед
		if(x0 < (x[0]+x[n-1])/2) 
		{
			dy0[0] = y[0];
			for(int i=1; i<p+2; i++)
				dy0[i] = dy[i-1][0];
			System.out.printf("\n\n");
			omega[0] = x0-x[0];
			for(int i=1; i<p+1; i++)
			{
				omega[i] = omega[i-1]*(x0-x[i]);
			}
		}
		else //Інакше інтерполяцію назад
		{
			dy0[0] = y[n-1];
			for(int i=1; i<p+2; i++)
				dy0[i] = dy[i-1][n-1-i];
			System.out.printf("\n\n");
			omega[0] = x0-x[n-1];
			for(int i=1; i<p+1; i++)
			{
				omega[i] = omega[i-1]*(x0-x[n-1-i]);
			}
		}
		double res = dy0[0];
		for(int i=1; i<p+2; i++)
		{
			res = res + dy0[i]*omega[i-1]; //Формула обчислення результату: значення інтерполянти в заданій точці
		}
		return res;
	}
}